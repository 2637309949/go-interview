`epoll` 通过以下几个关键机制和设计解决了 I/O 效率问题，特别是在处理大量并发连接时的性能瓶颈：

### 1. **事件驱动的通知机制**
`epoll` 基于事件驱动的机制来提高 I/O 操作的效率，而不是像 `select` 和 `poll` 那样每次都扫描整个文件描述符集。具体来说：

- **事件注册**：在使用 `epoll` 时，用户首先通过 `epoll_ctl` 系统调用将感兴趣的文件描述符（如 socket）注册到 `epoll` 实例中，并指定关注的事件（如可读、可写）。
- **事件等待**：用户通过 `epoll_wait` 系统调用等待事件发生。当有文件描述符上的事件（如数据到达）发生时，`epoll` 内核会将这些事件通知用户态程序。

这种方式避免了每次都遍历所有文件描述符，只关注状态变化的文件描述符，因此在大量并发连接下极大地提升了效率。

### 2. **O(1) 复杂度**
传统的 `select` 和 `poll` 是线性复杂度（O(n)），即在每次调用时都要遍历所有注册的文件描述符。这在大量文件描述符下性能会显著下降。而 `epoll` 的事件通知机制使得它的性能接近常数时间复杂度（O(1)），即无论监控多少文件描述符，处理每次 I/O 事件的时间几乎是固定的。

### 3. **边缘触发（ET, Edge-Triggered）模式**
`epoll` 支持边缘触发模式，只有在文件描述符的状态从未准备好变为准备好时才通知用户态。这减少了不必要的系统调用和上下文切换，但也要求用户态程序更精确地管理读取和写入操作，避免遗漏事件。

### 4. **内核和用户空间之间的消息传递方式**
在内核和用户空间之间，`epoll` 的消息传递主要通过以下方式进行：

- **共享内存机制**：`epoll` 的事件列表使用共享内存机制，使得内核将事件列表直接写入共享的用户空间内存区域，用户态程序通过 `epoll_wait` 直接读取这些事件。这减少了在内核态和用户态之间的数据拷贝操作，提升了性能。
  
- **减少系统调用次数**：由于 `epoll` 的事件驱动机制，用户程序只在有事件发生时调用 `epoll_wait`，而不需要像 `select` 和 `poll` 那样频繁地调用，减少了系统调用的开销。

- **批量处理**：`epoll_wait` 允许一次返回多个事件，使得用户态程序可以批量处理事件，而不是每次只处理一个。这进一步减少了内核态和用户态之间的切换，提高了效率。

### 5. **异步通知与低延迟**
`epoll` 支持异步通知，当文件描述符的状态发生变化时，内核会立即将这些变化记录在 `epoll` 实例中，这使得用户态程序在调用 `epoll_wait` 时能够迅速得到通知，保持低延迟响应。

### 6. **避免重复注册和扫描**
一旦文件描述符被注册到 `epoll` 实例中，除非用户显式取消注册，否则无需重复注册，这避免了像 `select` 那样每次调用都重新传递整个文件描述符集合的开销。此外，由于 `epoll` 内部使用高效的数据结构（如红黑树和链表），它可以快速地定位和管理这些文件描述符。

### 总结
`epoll` 通过事件驱动机制、接近 O(1) 的复杂度、边缘触发模式、共享内存和批量处理机制，极大地提高了多路复用 I/O 的效率，特别是在处理大量并发连接时表现出色。这些机制使得 `epoll` 在高性能服务器、网络代理、数据库中间件等需要处理大量并发 I/O 的场景中得到了广泛应用。